# Build workflow for histui
# - On version tags (v*): Create a release with clean semver
# - On main branch: Create a pre-release snapshot with dev version

name: Build Release

on:
  push:
    branches:
      - main
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      snapshot_retention:
        description: "Number of snapshot releases to keep"
        required: false
        default: "5"
        type: string

# Cancel in-progress runs for the same ref
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: stable
  SNAPSHOT_RETENTION: ${{ inputs.snapshot_retention || '5' }}

jobs:
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_tag: ${{ steps.version.outputs.version_tag }}
      is_release: ${{ steps.version.outputs.is_release }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          # Check if this is a release (tag push)
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            IS_RELEASE=true
            # Strip 'v' prefix from tag: v1.2.3 â†’ 1.2.3
            VERSION="${GITHUB_REF_NAME#v}"
            VERSION_TAG="${GITHUB_REF_NAME}"
          else
            IS_RELEASE=false
            # Snapshot version format: {major}.{minor}.{next_patch}-dev.{commits}+{hash}
            if git describe --tags --always --long 2>/dev/null | grep -q '^v'; then
              DESCRIBE=$(git describe --tags --always --long 2>/dev/null)
              # Parse: vMAJOR.MINOR.PATCH-COMMITS-gHASH
              if [[ $DESCRIBE =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)-([0-9]+)-g([a-f0-9]+)$ ]]; then
                MAJOR=${BASH_REMATCH[1]}
                MINOR=${BASH_REMATCH[2]}
                PATCH=${BASH_REMATCH[3]}
                COMMITS=${BASH_REMATCH[4]}
                HASH=${BASH_REMATCH[5]}
                # Increment patch for dev version
                NEXT_PATCH=$((PATCH + 1))
                VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}-dev.${COMMITS}+${HASH}"
                VERSION_TAG="v${MAJOR}.${MINOR}.${NEXT_PATCH}-dev.${COMMITS}"
              else
                # Fallback if pattern doesn't match
                SHORT_SHA=$(git rev-parse --short=7 HEAD)
                VERSION="0.0.1-dev.0+${SHORT_SHA}"
                VERSION_TAG="v0.0.1-dev.0-${SHORT_SHA}"
              fi
            else
              # No tags: initial dev version based on commit count
              COMMITS=$(git rev-list --count HEAD)
              SHORT_SHA=$(git rev-parse --short=7 HEAD)
              VERSION="0.0.1-dev.${COMMITS}+${SHORT_SHA}"
              VERSION_TAG="v0.0.1-dev.${COMMITS}"
            fi
          fi

          echo "is_release=${IS_RELEASE}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
          echo "Is release: ${IS_RELEASE}"
          echo "Version: ${VERSION}"
          echo "Version tag: ${VERSION_TAG}"

  build:
    name: Build (${{ matrix.goos }}/${{ matrix.goarch }})
    runs-on: ${{ matrix.os }}
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - goos: linux
            goarch: amd64
            os: ubuntu-latest
          - goos: linux
            goarch: arm64
            os: ubuntu-24.04-arm
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run tests
        run: go test ./...

      - name: Build histui
        env:
          CGO_ENABLED: 0
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: |
          go build -ldflags "-s -w -X main.version=${{ needs.prepare.outputs.version }} -X main.commit=${{ github.sha }} -X main.buildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ)" -o histui ./cmd/histui

      - name: Create archive
        run: |
          mkdir -p dist
          tar -czvf dist/histui_${{ needs.prepare.outputs.version }}_${{ matrix.goos }}_${{ matrix.goarch }}.tar.gz \
            histui \
            LICENSE \
            README.md

      - name: Upload artifact
        uses: actions/upload-artifact@v6
        with:
          name: histui_${{ needs.prepare.outputs.version }}_${{ matrix.goos }}_${{ matrix.goarch }}
          path: dist/*.tar.gz
          retention-days: 1

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [prepare, build]
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v7
        with:
          path: artifacts
          merge-multiple: false

      - name: Prepare release assets
        run: |
          mkdir -p release
          find artifacts -name "*.tar.gz" -exec mv {} release/ \;
          echo "=== Release assets ==="
          ls -la release/

      - name: Generate checksums
        run: |
          cd release
          sha256sum *.tar.gz > checksums.txt
          echo "=== Checksums ==="
          cat checksums.txt

      - name: Generate changelog
        run: |
          if [[ "${{ needs.prepare.outputs.is_release }}" == "true" ]]; then
            PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
            if [ -n "$PREV_TAG" ]; then
              echo "## Changelog" > changelog.txt
              echo "" >> changelog.txt
              git log --pretty=format:"* %h %s" $PREV_TAG..HEAD | \
                grep -v "^* [a-f0-9]* docs:" | \
                grep -v "^* [a-f0-9]* test:" | \
                grep -v "^* [a-f0-9]* ci:" | \
                grep -v "^* [a-f0-9]* Merge" >> changelog.txt || echo "* No notable changes" >> changelog.txt
            else
              echo "* Initial release" > changelog.txt
            fi
          else
            cat > changelog.txt << EOF
          **Automated snapshot build from main branch**

          Version: \`${{ needs.prepare.outputs.version }}\`
          Commit: \`${{ github.sha }}\`

          This is an unstable development build. Use at your own risk.
          EOF
          fi
          echo "=== Changelog ==="
          cat changelog.txt

      - name: Create release
        run: |
          if [[ "${{ needs.prepare.outputs.is_release }}" == "true" ]]; then
            gh release create "${{ needs.prepare.outputs.version_tag }}" \
              --title "${{ needs.prepare.outputs.version_tag }}" \
              --notes-file changelog.txt \
              release/*
          else
            gh release create "${{ needs.prepare.outputs.version_tag }}" \
              --title "Snapshot ${{ needs.prepare.outputs.version }}" \
              --prerelease \
              --notes-file changelog.txt \
              release/*
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup old snapshot releases
        if: needs.prepare.outputs.is_release != 'true'
        run: |
          RETENTION=${{ env.SNAPSHOT_RETENTION }}
          echo "Keeping ${RETENTION} most recent snapshot releases"

          # List snapshot prereleases, newest first
          SNAPSHOTS=$(gh release list --limit 50 --json tagName,isPrerelease \
            --jq '.[] | select(.isPrerelease) | select(.tagName | test("^v[0-9]+\\.[0-9]+\\.[0-9]+-dev\\.")) | .tagName')

          COUNT=0
          for TAG in $SNAPSHOTS; do
            COUNT=$((COUNT + 1))
            if [ $COUNT -gt $RETENTION ]; then
              echo "Deleting old snapshot release: ${TAG}"
              gh release delete "${TAG}" --yes --cleanup-tag || true
            fi
          done

          echo "Cleanup complete. Kept ${RETENTION} most recent snapshots."
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
